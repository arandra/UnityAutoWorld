# Core 개선 계획

## 개요
- 코어만으로 게임 루프를 구동하기 위한 보강 항목을 정리한다.
- Unity 등 외부 플랫폼은 틱 호출과 이벤트 출력 같은 인터페이스만 사용하도록 한다.

## 작업 항목
### 1. 틱 축 확장
- `AutoWorld/Assets/Scripts/Core/ITickScheduler.cs`를 구현하는 `ManualTickScheduler`를 추가해 틱 인덱스와 경과 시간을 계산하고 `ITickListener`에게 전달한다.
- 틱 호출자는 `AdvanceTick`(가칭)을 직접 호출하며, 틱 간격은 `InitConst`에 저장된 초기값을 참조하고 런타임에 `ITickScheduler.SetTickDuration`으로 조정 가능해야 한다.

### 2. 도메인 주체 정의
- 필드(FieldDefinition), 주민, 자원 풀 등 상태를 가진 클래스를 작성하고 필요한 경우 `IEventParticipant`, `ITickListener`, `IEventListener`를 구현한다.
- 각 객체는 자신의 상태를 틱마다 갱신하고, 필요 시 `EventManager`에 이벤트를 발생시킨다.

### 3. 레지스트리 안전장치
- `EventObjectRegistry` 위에 타입별 조회와 ID 발급을 담당하는 헬퍼를 도입해 등록 과정에서의 중복과 누락을 방지한다.
- 참가자 등록과 해제를 위한 일관된 서비스 인터페이스를 마련한다.

### 4. 초기화 파이프라인
- 코어 전용 부트스트래퍼를 만들어 기본 데이터 묶음(FieldDefinition, InitConst 등)과 도메인 객체를 생성하고 레지스트리에 등록한다.
- 부트스트래퍼는 틱 스케줄러와 도메인 객체를 연결하며 전체 루프를 시작한다.

### 5. 외부 연동 어댑터
- 코어가 `ICoreEvents` 같은 얇은 추상 인터페이스를 제공해 외부 플랫폼이 이벤트 구독과 틱 호출을 안전하게 수행하게 한다.
- Unity나 서버 등 각 환경은 이 인터페이스를 구현하거나 어댑터를 구성해 접속한다.

### 6. 검증 도구
- 틱 흐름, 이벤트 발행, 레지스트리 조회를 검증할 콘솔 기반 시뮬레이션이나 단위 테스트를 마련한다.
- 자동화된 테스트를 통해 코어 변경 시 회귀를 빠르게 감지한다.

## 다음 단계 제안
1. ManualTickScheduler와 기본 `ITickListener` 틀을 구현해 InitConst 기반 초기 틱 간격을 적용한다.
2. 도메인 상태 객체와 레지스트리 헬퍼 설계를 확정한다.
3. 코어만 사용하는 간단한 콘솔 예제를 작성해 전체 흐름을 검증한다.
